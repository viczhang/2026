<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2026 Celebration</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM (UMD for simple static deployment) -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
    
    <!-- Babel Standalone for in-browser JSX compilation -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
      body, html {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background-color: #000;
      }
      canvas {
        display: block;
      }
    </style>
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@^19.2.3",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/"
  }
}
</script>
</head>
  <body>
    <div id="root"></div>

    <!-- Removed 'typescript' preset and converted code to plain JSX/JS to avoid compilation issues -->
    <script type="text/babel" data-presets="react">
      const { useState, useEffect, useRef } = React;

      // ---------------------------------------------------------
      // COMPONENT: FireworksDisplay
      // ---------------------------------------------------------

      const FireworksDisplay = ({ audioEnabled }) => {
        const canvasRef = useRef(null);
        const [dimensions, setDimensions] = useState({ width: 0, height: 0 });

        // Audio Refs
        const audioCtxRef = useRef(null);
        const audioEnabledRef = useRef(audioEnabled);
        const noiseBufferRef = useRef(null);

        // Sync prop to ref
        useEffect(() => {
          audioEnabledRef.current = audioEnabled;
          
          if (audioEnabled && !audioCtxRef.current) {
            // Access AudioContext safely checking both standard and webkit prefixes
            const AudioContextClass = window.AudioContext || window.webkitAudioContext;
            if (AudioContextClass) {
              const ctx = new AudioContextClass();
              audioCtxRef.current = ctx;
              
              // Create noise buffer for explosion sounds
              const bufferSize = ctx.sampleRate * 2;
              const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
              const data = buffer.getChannelData(0);
              for (let i = 0; i < bufferSize; i++) {
                data[i] = Math.random() * 2 - 1;
              }
              noiseBufferRef.current = buffer;
            }
          }

          if (audioEnabled && audioCtxRef.current && audioCtxRef.current.state === 'suspended') {
            audioCtxRef.current.resume();
          }
        }, [audioEnabled]);

        useEffect(() => {
          const handleResize = () => {
            setDimensions({
              width: window.innerWidth,
              height: window.innerHeight,
            });
          };
          
          window.addEventListener('resize', handleResize);
          handleResize();

          return () => window.removeEventListener('resize', handleResize);
        }, []);

        useEffect(() => {
          const canvas = canvasRef.current;
          if (!canvas || dimensions.width === 0) return;

          const ctx = canvas.getContext('2d', { alpha: false });
          if (!ctx) return;

          canvas.width = dimensions.width;
          canvas.height = dimensions.height;

          // --- Configuration ---
          const TEXT = "2026";
          const FONT_SIZE = Math.min(dimensions.width * 0.25, 300);
          const FONT = `900 ${FONT_SIZE}px sans-serif`;
          
          // --- State ---
          let textPoints = [];
          let sparklerParticles = [];
          let fireworks = [];
          let animationFrameId;
          let tick = 0;

          // --- Audio Helper Functions ---
          const playExplosionSound = () => {
            if (!audioEnabledRef.current || !audioCtxRef.current || !noiseBufferRef.current) return;
            
            const ctx = audioCtxRef.current;
            const t = ctx.currentTime;
            
            const source = ctx.createBufferSource();
            source.buffer = noiseBufferRef.current;
            
            const filter = ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(400, t);
            filter.frequency.exponentialRampToValueAtTime(100, t + 0.3);

            const gain = ctx.createGain();
            gain.gain.setValueAtTime(0, t);
            gain.gain.linearRampToValueAtTime(0.2, t + 0.02);
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.5);

            source.connect(filter);
            filter.connect(gain);
            gain.connect(ctx.destination);
            
            source.start(t);
            source.stop(t + 0.6);
          };

          const playSparkleCrackles = () => {
              if (!audioEnabledRef.current || !audioCtxRef.current || !noiseBufferRef.current) return;
              
              if (Math.random() > 0.15) return; 

              const ctx = audioCtxRef.current;
              const t = ctx.currentTime;
              
              const source = ctx.createBufferSource();
              source.buffer = noiseBufferRef.current;
              
              const filter = ctx.createBiquadFilter();
              filter.type = 'highpass';
              filter.frequency.value = 5000;

              const gain = ctx.createGain();
              const volume = 0.02 + Math.random() * 0.03;
              gain.gain.setValueAtTime(volume, t);
              gain.gain.exponentialRampToValueAtTime(0.001, t + 0.05);

              source.connect(filter);
              filter.connect(gain);
              gain.connect(ctx.destination);
              
              const randomOffset = Math.random() * (noiseBufferRef.current.duration - 0.1);
              source.start(t, randomOffset, 0.1);
          };

          // --- Helper Functions ---
          const generateTextPoints = () => {
            const offCanvas = document.createElement('canvas');
            offCanvas.width = dimensions.width;
            offCanvas.height = dimensions.height;
            const offCtx = offCanvas.getContext('2d');
            if (!offCtx) return [];

            offCtx.font = FONT;
            offCtx.textAlign = 'center';
            offCtx.textBaseline = 'middle';
            offCtx.fillStyle = '#FFFFFF';
            offCtx.fillText(TEXT, dimensions.width / 2, dimensions.height / 2);

            const imageData = offCtx.getImageData(0, 0, dimensions.width, dimensions.height);
            const data = imageData.data;
            const points = [];
            // Increase density gap (reduce point count) on smaller screens
            const density = dimensions.width < 800 ? 6 : 4;

            for (let y = 0; y < dimensions.height; y += density) {
              for (let x = 0; x < dimensions.width; x += density) {
                const alpha = data[(y * dimensions.width + x) * 4 + 3];
                if (alpha > 128) {
                  points.push({ x, y });
                }
              }
            }
            return points;
          };

          const createSparklerParticle = (x, y) => {
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 1.5;
            return {
              x,
              y,
              vx: Math.cos(angle) * speed,
              vy: Math.sin(angle) * speed,
              life: 1.0,
              maxLife: 1.0,
              color: `hsl(${30 + Math.random() * 30}, 100%, ${50 + Math.random() * 50}%)`,
              size: Math.random() * 2 + 0.5,
              alpha: 1,
              decay: Math.random() * 0.05 + 0.02
            };
          };

          const createFirework = () => {
            const x = Math.random() * dimensions.width;
            const startY = dimensions.height;
            const targetY = dimensions.height * 0.1 + Math.random() * (dimensions.height * 0.4);
            const hue = Math.random() * 360;
            
            return {
              x,
              y: startY,
              targetY,
              vx: (Math.random() - 0.5) * 4,
              vy: -(Math.random() * 3 + 12),
              hue,
              particles: [],
              state: 'rising',
              trail: []
            };
          };

          const explodeFirework = (fw) => {
            playExplosionSound();

            const particleCount = 80 + Math.random() * 50;
            for (let i = 0; i < particleCount; i++) {
              const angle = Math.random() * Math.PI * 2;
              const speed = Math.random() * 6 + 1;
              
              fw.particles.push({
                x: fw.x,
                y: fw.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed,
                life: 1.0,
                maxLife: 1.0,
                color: `hsl(${fw.hue}, 100%, 60%)`,
                size: Math.random() * 3 + 1,
                alpha: 1,
                decay: Math.random() * 0.015 + 0.01
              });
            }
            fw.state = 'exploded';
          };

          // --- Init ---
          textPoints = generateTextPoints();

          // --- Animation Loop ---
          const render = () => {
            tick++;
            
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.fillRect(0, 0, dimensions.width, dimensions.height);

            // Responsive emission rate: Fewer particles on smaller screens
            // Approx 20 particles on 400px width, 96 on 1920px width
            const emissionRate = Math.max(15, Math.floor(dimensions.width / 20));

            for (let i = 0; i < emissionRate; i++) {
              if (textPoints.length > 0) {
                const randIndex = Math.floor(Math.random() * textPoints.length);
                const p = textPoints[randIndex];
                sparklerParticles.push(createSparklerParticle(p.x, p.y));
              }
            }

            if (textPoints.length > 0) {
              playSparkleCrackles();
            }

            for (let i = sparklerParticles.length - 1; i >= 0; i--) {
              const p = sparklerParticles[i];
              p.x += p.vx;
              p.y += p.vy;
              p.life -= p.decay;
              p.vy += 0.05;

              if (p.life <= 0) {
                sparklerParticles.splice(i, 1);
                continue;
              }

              ctx.globalCompositeOperation = 'lighter';
              ctx.fillStyle = p.color;
              ctx.globalAlpha = p.life;
              ctx.beginPath();
              ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
              ctx.fill();
              ctx.globalAlpha = 1;
            }

            // Fireworks
            if (Math.random() < 0.03) {
              fireworks.push(createFirework());
            }

            for (let i = fireworks.length - 1; i >= 0; i--) {
              const fw = fireworks[i];
              
              if (fw.state === 'rising') {
                fw.x += fw.vx;
                fw.y += fw.vy;
                fw.vy += 0.2;
                
                ctx.strokeStyle = `hsla(${fw.hue}, 100%, 50%, 0.5)`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(fw.x, fw.y);
                ctx.lineTo(fw.x - fw.vx * 3, fw.y - fw.vy * 3);
                ctx.stroke();

                if (fw.vy >= 0 || fw.y <= fw.targetY) {
                  explodeFirework(fw);
                }
              } else if (fw.state === 'exploded') {
                let aliveParticles = false;
                for (const p of fw.particles) {
                  if (p.life > 0) {
                    aliveParticles = true;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05;
                    p.vx *= 0.96;
                    p.vy *= 0.96;
                    p.life -= p.decay;
                    
                    ctx.fillStyle = p.color;
                    ctx.globalAlpha = Math.max(0, p.life);
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                  }
                }
                if (!aliveParticles) {
                  fw.state = 'dead';
                }
              }
              
              if (fw.state === 'dead') {
                fireworks.splice(i, 1);
              }
            }
            ctx.globalAlpha = 1;
            ctx.globalCompositeOperation = 'source-over';

            animationFrameId = requestAnimationFrame(render);
          };

          render();

          return () => {
            cancelAnimationFrame(animationFrameId);
          };
        }, [dimensions]);

        return (
          <canvas 
            ref={canvasRef} 
            className="block w-full h-full"
          />
        );
      };

      // ---------------------------------------------------------
      // COMPONENT: App
      // ---------------------------------------------------------

      const App = () => {
        const [audioEnabled, setAudioEnabled] = useState(false);
        const [isFullscreen, setIsFullscreen] = useState(false);

        useEffect(() => {
            const handleFullscreenChange = () => {
                setIsFullscreen(!!document.fullscreenElement);
            };
            document.addEventListener('fullscreenchange', handleFullscreenChange);
            return () => document.removeEventListener('fullscreenchange', handleFullscreenChange);
        }, []);

        const toggleFullscreen = () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch((e) => {
                    console.error(`Error attempting to enable fullscreen mode: ${e.message} (${e.name})`);
                });
            } else {
                if (document.exitFullscreen) {
                   document.exitFullscreen();
                }
            }
        };

        return (
          <div className="relative w-screen h-screen bg-black overflow-hidden">
            <FireworksDisplay audioEnabled={audioEnabled} />
            
            <div className="absolute top-4 right-4 z-50 flex gap-2">
                {/* Fullscreen Toggle */}
                <button
                    onClick={toggleFullscreen}
                    className="p-2 text-white/50 hover:text-white transition-colors duration-300"
                    aria-label={isFullscreen ? "Exit Fullscreen" : "Enter Fullscreen"}
                >
                    {isFullscreen ? (
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M9 9V4.5M9 9H4.5M9 9L3.75 3.75M9 15v4.5M9 15H4.5M9 15l-5.25 5.25M15 9h4.5M15 9V4.5M15 9l5.25-5.25M15 15h4.5M15 15v4.5M15 15l5.25 5.25" />
                        </svg>
                    ) : (
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                            <path strokeLinecap="round" strokeLinejoin="round" d="M3.75 3.75v4.5m0-4.5h4.5m-4.5 0L9 9M3.75 20.25v-4.5m0 4.5h4.5m-4.5 0L9 15M20.25 3.75h-4.5m4.5 0v4.5m0-4.5L15 9m5.25 11.25h-4.5m4.5 0v-4.5m0 4.5L15 15" />
                        </svg>
                    )}
                </button>

                {/* Audio Toggle Button */}
                <button 
                  onClick={() => setAudioEnabled(!audioEnabled)}
                  className="p-2 text-white/50 hover:text-white transition-colors duration-300"
                  aria-label={audioEnabled ? "Mute sound" : "Unmute sound"}
                >
                  {audioEnabled ? (
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                      <path strokeLinecap="round" strokeLinejoin="round" d="M19.114 5.636a9 9 0 0 1 0 12.728M16.463 8.288a5.25 5.25 0 0 1 0 7.424M6.75 8.25l4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
                    </svg>
                  ) : (
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
                      <path strokeLinecap="round" strokeLinejoin="round" d="M17.25 9.75 19.5 12m0 0 2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6 4.72-4.72a.75.75 0 0 1 1.28.53v15.88a.75.75 0 0 1-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.009 9.009 0 0 1 2.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75Z" />
                    </svg>
                  )}
                </button>
            </div>

            <div className="absolute bottom-4 left-0 right-0 text-center pointer-events-none opacity-50">
              <p className="text-white text-xs font-light tracking-widest uppercase">Happy New Year</p>
            </div>
          </div>
        );
      };

      // ---------------------------------------------------------
      // ROOT
      // ---------------------------------------------------------

      const rootElement = document.getElementById('root');
      if (rootElement) {
        const root = ReactDOM.createRoot(rootElement);
        root.render(<App />);
      }
    </script>
  </body>
</html>